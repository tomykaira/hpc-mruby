/* Generated by HPC mruby compiler */
#include <stdio.h>
#include <stdlib.h>
#include "mruby.h"
#include "mruby/variable.h"
#include "mruby/class.h"


#include "../hpcmrb.h"
//#include "mruby.h"
#include "mruby/value.h"
#include "mruby/string.h"
#include "mruby/array.h" /* mrb_ary_ref */
#include <limits.h> /* CHAR_BIT macro */
#include <string.h> /* memcpy */
#include <math.h>
//#include <stdlib.h>

#define TYPES2(a,b) ((((uint16_t)(a))<<8)|(((uint16_t)(b))&0xff))

mrb_value hpc_str_plus(mrb_value, mrb_value);

extern mrb_state *mrb; /* using mrb_state in the driver-main */

mrb_value
num_add_1(int val, mrb_value a, mrb_value b)
{
  switch (TYPES2(mrb_type(a), mrb_type(b))) {
  case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):
    {
      mrb_int x, y, z;
      x = mrb_fixnum(a);
      y = mrb_fixnum(b);
      z = x + y;
      if ((x < 0) != (z < 0) && ((x < 0) ^ (y < 0)) == 0) {
        /* integer overflow */
        return mrb_float_value((mrb_float)x + (mrb_float)y);
      }
      return mrb_fixnum_value(z);
    }
  case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):
    return mrb_float_value((mrb_float)mrb_fixnum(a) + mrb_float(b));
  case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):
    return mrb_float_value(mrb_float(a) + (mrb_float)mrb_fixnum(b));
  case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):
    return mrb_float_value(mrb_float(a) + mrb_float(b));
  case TYPES2(MRB_TT_STRING,MRB_TT_STRING):
    return hpc_str_plus(a, b);
  default:
    NOT_REACHABLE();
  }
}

mrb_value
num_addi_1(int val, mrb_value a, mrb_int b)
{
  switch (mrb_type(a)) {
  case MRB_TT_FIXNUM:
    {
      mrb_int x, y, z;
      x = mrb_fixnum(a);
      y = b;
      z = x + y;
      if ((x < 0) != (z < 0) && ((x < 0) ^ (y < 0)) == 0) {
        /* integer overflow */
        return mrb_float_value((mrb_float)x + (mrb_float)y);
      }
      return mrb_fixnum_value(z);
    }
  case MRB_TT_FLOAT:
    return mrb_float_value(mrb_float(a) + (mrb_float)b);
  default:
    NOT_REACHABLE();
  }
}

mrb_value
num_sub_1(int val, mrb_value a, mrb_value b)
{
  switch (TYPES2(mrb_type(a), mrb_type(b))) {
  case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):
    {
      mrb_int x, y, z;
      x = mrb_fixnum(a);
      y = mrb_fixnum(b);
      z = x - y;
      if (((x < 0) ^ (y < 0)) != 0 && (x < 0) != (z < 0)) {
        /* integer overflow */
        return mrb_float_value((mrb_float)x - (mrb_float)y);
      }
      return mrb_fixnum_value(z);
    }
  case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):
    return mrb_float_value((mrb_float)mrb_fixnum(a) - mrb_float(b));
  case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):
    return mrb_float_value(mrb_float(a) - (mrb_float)mrb_fixnum(b));
  case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):
    return mrb_float_value(mrb_float(a) - mrb_float(b));
  default:
    NOT_REACHABLE();
  }
}

mrb_value
num_subi_1(int val, mrb_value a, mrb_int b)
{
  switch (mrb_type(a)) {
  case MRB_TT_FIXNUM:
    {
      mrb_int x, y, z;
      x = mrb_fixnum(a);
      y = b;
      z = x - y;
      if (((x < 0) ^ (y < 0)) != 0 && (x < 0) != (z < 0)) {
        /* integer overflow */
        return mrb_float_value((mrb_float)x - (mrb_float)y);
      }
      return mrb_fixnum_value(z);
    }
  case MRB_TT_FLOAT:
    return mrb_float_value(mrb_float(a) - (mrb_float)b);
  default:
    NOT_REACHABLE();
  }
}

mrb_value
num_mul_1(int val, mrb_value a, mrb_value b)
{
  switch (TYPES2(mrb_type(a), mrb_type(b))) {
  case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):
    {
      mrb_int x, y, z;
      x = mrb_fixnum(a);
      y = mrb_fixnum(b);
      z = x * y;
      if (x != 0 && z/x != y) {
        /* integer overflow */
        return mrb_float_value((mrb_float)x * (mrb_float)y);
      }
      return mrb_fixnum_value(z);
    }
  case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):
    return mrb_float_value((mrb_float)mrb_fixnum(a) * mrb_float(b));
  case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):
    return mrb_float_value(mrb_float(a) * (mrb_float)mrb_fixnum(b));
  case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):
    return mrb_float_value(mrb_float(a) * mrb_float(b));
  default:
    NOT_REACHABLE();
  }
}

mrb_value
num_div_1(int val, mrb_value a, mrb_value b)
{
  switch (TYPES2(mrb_type(a), mrb_type(b))) {
  case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):
    {
      mrb_int x, y;
      x = mrb_fixnum(a);
      y = mrb_fixnum(b);
      return mrb_float_value((mrb_float)x / (mrb_float)y);
    }
  case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):
    return mrb_float_value((mrb_float)mrb_fixnum(a) / mrb_float(b));
  case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):
    return mrb_float_value(mrb_float(a) / (mrb_float)mrb_fixnum(b));
  case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):
    return mrb_float_value(mrb_float(a) / mrb_float(b));
  default:
    NOT_REACHABLE();
  }
}

#define BINOP(op)                               \
  mrb_int x, y;                                 \
  x = mrb_fixnum(a);                            \
  y = mrb_fixnum(b);                            \
  return mrb_fixnum_value(x op y);              \

mrb_value
num_xor_1(int val, mrb_value a, mrb_value b)
{
  BINOP(^)
}

mrb_value
num_lshift_1(int val, mrb_value a, mrb_value b)
{
  BINOP(<<)
}

mrb_value
num_rshift_1(int val, mrb_value a, mrb_value b)
{
  BINOP(>>)
}

mrb_value
num_and_1(int val, mrb_value a, mrb_value b)
{
  BINOP(&)
}

mrb_value
num_mod_1(int val, mrb_value a, mrb_value b)
{
  BINOP(%)
}

#define OP_CMP_BODY(op,v1,v2) do {\
  if (a.value.v1 op b.value.v2) {\
    return mrb_true_value();\
  }\
  else {\
    return mrb_false_value();\
  }\
} while(0)

#define OP_CMP(op) do {\
  /* need to check if - is overridden */\
  switch (TYPES2(mrb_type(a),mrb_type(b))) {\
  case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\
    OP_CMP_BODY(op,i,i);\
  case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\
    OP_CMP_BODY(op,i,f);\
  case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\
    OP_CMP_BODY(op,f,i);\
  case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\
    OP_CMP_BODY(op,f,f);\
  default:\
    NOT_REACHABLE();\
  }\
} while (0)

mrb_value
num_eq_1(int val, mrb_value a, mrb_value b)
{
  if (mrb_type(a) != MRB_TT_FIXNUM
      && mrb_type(a) != MRB_TT_FLOAT) {
    return mrb_bool_value(mrb_obj_eq(mrb, a, b));
  }
  else {
    OP_CMP(==);
  }
}

mrb_value
num_lt_1(int val, mrb_value a, mrb_value b)
{
  OP_CMP(<);
}

mrb_value
num_le_1(int val, mrb_value a, mrb_value b)
{
  OP_CMP(<=);
}

mrb_value
num_gt_1(int val, mrb_value a, mrb_value b)
{
  OP_CMP(>);
}

mrb_value
num_ge_1(int val, mrb_value a, mrb_value b)
{
  OP_CMP(>=);
}


/* almost copied from string.c(mrb_str_plus) */
mrb_value
hpc_str_plus(mrb_value a, mrb_value b)
{
  struct RString *s = mrb_str_ptr(a);
  struct RString *s2 = mrb_str_ptr(b);


  mrb_value v = mrb_str_new(mrb, 0, s->len + s2->len);
  struct RString *t = mrb_str_ptr(v);

  memcpy(t->ptr, s->ptr, s->len);
  memcpy(t->ptr + s->len, s2->ptr, s2->len);

  return v;
}

/* almost copied from numeric.c(mrb_fixnum_to_str) */
mrb_value
hpc_fixnum_to_str(int val, mrb_value x, int base)
{
  char buf[sizeof(mrb_int)*CHAR_BIT+1];
  char *b = buf + sizeof buf;
  mrb_int v = mrb_fixnum(x);

  if (base < 2 || 36 < base) {
    mrb_raisef(mrb, E_ARGUMENT_ERROR, "invid radix %S", mrb_fixnum_value(base));
  }

  if (v == 0) {
    *--b = '0';
  } else if (v < 0) {
    do {
      *--b = mrb_digitmap[-(v % base)];
    } while (v /= base);
    *--b = '-';
  } else {
    do {
      *--b = mrb_digitmap[(int)(v % base)];
    } while (v /= base);
  }

  return mrb_str_new(mrb, b, buf + sizeof(buf) - b);
}

/* value n's type is expected to be <string> or <fixnum> */
mrb_value
puts_1(int val, mrb_value __self__, mrb_value n)
{
  mrb_value str = mrb_funcall(mrb, n, "to_s", 0);
  const char *cstr = mrb_str_to_cstr(mrb, str);
  puts(cstr);
  return mrb_nil_value();
}


extern FILE *debug_fp;
mrb_value
print_1(int val, mrb_value __self__, mrb_value n)
{
  if (!mrb_string_p(n))
    n = mrb_funcall(mrb, n, "to_s", 0);
  const char *cstr = RSTRING_PTR(n);
  size_t i, len = RSTRING_LEN(n);
  for (i = 0; i < len; ++i) {
    if (debug_fp) {
      putc(cstr[i], debug_fp);
      fflush(debug_fp);
    } else {
      putchar(cstr[i]);
    }
  }
  return mrb_nil_value();
}

mrb_value
bob_not_0(int val, mrb_value __self__)
{
  return mrb_bool_value(!mrb_test(__self__));
}

mrb_value
hpc_ary_aget_1(int val, mrb_value __self__, mrb_value index)
{
  if(mrb_type(index) == MRB_TT_FIXNUM){
    return mrb_ary_ref(mrb, __self__, mrb_fixnum(index));
  }
  puts("TYPE_ERROR: expected Fixnum for 1st argument (hpc_ary_aget)");
  return mrb_nil_value();
}

mrb_value
hpc_ary_aset_2(int val, mrb_value __self__, mrb_value index, mrb_value value)
{
  int ai;
  if (!val)
    ai = mrb_gc_arena_save(mrb);
  if(mrb_type(index) == MRB_TT_FIXNUM){
    mrb_ary_set(mrb, __self__, mrb_fixnum(index), value);
    goto end;
  }
  puts("TYPE_ERROR: expected Fixnum for 1st argument (hpc_ary_aset)");
  value = mrb_nil_value();

 end:
  if (!val)
    mrb_gc_arena_restore(mrb, ai);
  return value;
}

#define EVAL_FLOAT(num, exp) do {               \
  mrb_float f;                                  \
  switch (mrb_type(num)) {                      \
  case MRB_TT_FIXNUM:                           \
    f = (mrb_float)mrb_fixnum(num);             \
    break;                                      \
  case MRB_TT_FLOAT:                            \
    f = mrb_float(num);                         \
    break;                                      \
  default:                                      \
    puts("TypeError: can't be coerced into Float"); \
    return mrb_float_value(nan(""));            \
  }                                             \
  return mrb_float_value(exp);                  \
} while (1)

mrb_value
sqrt_1(int val, mrb_value __self__, mrb_value num)
{
  EVAL_FLOAT(num, sqrt(f));
}

mrb_value
cos_1(int val, mrb_value __self__, mrb_value num)
{
  EVAL_FLOAT(num, cos(f));
}

mrb_value
sin_1(int val, mrb_value __self__, mrb_value num)
{
  EVAL_FLOAT(num, sin(f));
}

mrb_value
num_uminus_0(int val, mrb_value num)
{
  switch (mrb_type(num)) {
  case MRB_TT_FIXNUM:
    return mrb_fixnum_value(0 - mrb_fixnum(num));
  case MRB_TT_FLOAT:
    return mrb_float_value(0 - mrb_float(num));
  default:
    return mrb_funcall(mrb, num, "-@", 0);
  }
}

mrb_value
to_i_0(int val, mrb_value num)
{
  switch (mrb_type(num)) {
  case MRB_TT_FIXNUM:
    return num;
  case MRB_TT_FLOAT:
    return mrb_fixnum_value((mrb_int)mrb_float(num));
  default:
    return mrb_funcall(mrb, num, "to_i", 0);
  }
}

mrb_value
to_f_0(int val, mrb_value num)
{
  switch (mrb_type(num)) {
  case MRB_TT_FIXNUM:
    return mrb_float_value((mrb_float)mrb_fixnum(num));
  case MRB_TT_FLOAT:
    return num;
  default:
    return mrb_funcall(mrb, num, "to_i", 0);
  }
}

mrb_value
chr_0(int val, mrb_value num)
{
  switch (mrb_type(num)) {
  case MRB_TT_FIXNUM:
    {
      char c;
      c = (char)mrb_fixnum(num);
      return mrb_str_new(mrb, &c, 1);
    }
  default:
    return mrb_funcall(mrb, num, "chr", 0);
  }
}

mrb_value
to_s_0(int val, mrb_value __self__)
{
  return mrb_funcall(mrb, __self__, "to_s", 0);
}

//#include "builtin.h"

extern mrb_state * mrb;

mrb_value
Rand_rand(mrb_value __self__);
mrb_value
Vec_vnormalize(mrb_value __self__);
mrb_value
Vec_vlength(mrb_value __self__);
mrb_value
Vec_vdot(mrb_value __self__, mrb_value b);
mrb_value
Vec_vcross(mrb_value __self__, mrb_value b);
mrb_value
Vec_vsub(mrb_value __self__, mrb_value b);
mrb_value
Vec_vadd(mrb_value __self__, mrb_value b);
mrb_value
Vec_z(mrb_value __self__);
mrb_value
Vec_y(mrb_value __self__);
mrb_value
Vec_x(mrb_value __self__);
mrb_value
Vec_z_set(mrb_value __self__, mrb_value v);
mrb_value
Vec_y_set(mrb_value __self__, mrb_value v);
mrb_value
Vec_x_set(mrb_value __self__, mrb_value v);
mrb_value
Vec_initialize(mrb_value __self__, mrb_value x, mrb_value y, mrb_value z);
mrb_value
Sphere_intersect(mrb_value __self__, mrb_value ray, mrb_value isect);
mrb_value
Sphere_radius(mrb_value __self__);
mrb_value
Sphere_center(mrb_value __self__);
mrb_value
Sphere_initialize(mrb_value __self__, mrb_value center, mrb_value radius);
mrb_value
Plane_intersect(mrb_value __self__, mrb_value ray, mrb_value isect);
mrb_value
Plane_initialize(mrb_value __self__, mrb_value p, mrb_value n);
mrb_value
Ray_dir_set(mrb_value __self__, mrb_value v);
mrb_value
Ray_dir(mrb_value __self__);
mrb_value
Ray_org_set(mrb_value __self__, mrb_value v);
mrb_value
Ray_org(mrb_value __self__);
mrb_value
Ray_initialize(mrb_value __self__, mrb_value org, mrb_value dir);
mrb_value
Isect_n_set(mrb_value __self__, mrb_value v);
mrb_value
Isect_n(mrb_value __self__);
mrb_value
Isect_pl_set(mrb_value __self__, mrb_value v);
mrb_value
Isect_pl(mrb_value __self__);
mrb_value
Isect_hit_set(mrb_value __self__, mrb_value v);
mrb_value
Isect_hit(mrb_value __self__);
mrb_value
Isect_t_set(mrb_value __self__, mrb_value v);
mrb_value
Isect_t(mrb_value __self__);
mrb_value
Isect_initialize(mrb_value __self__);
mrb_value
clamp(mrb_value __self__, mrb_value f);
mrb_value
otherBasis(mrb_value __self__, mrb_value basis, mrb_value n);
mrb_value
Scene_render(mrb_value __self__, mrb_value w, mrb_value h, mrb_value nsubsamples);
mrb_value
Scene_ambient_occlusion(mrb_value __self__, mrb_value isect);
mrb_value
Scene_initialize(mrb_value __self__);
void
compiled_main(mrb_value __self__, mrb_state * mrb);
mrb_value
render_3(int val, mrb_value __self__, mrb_value arg0, mrb_value arg1, mrb_value arg2);
mrb_value
ambient_occlusion_1(int val, mrb_value __self__, mrb_value arg0);
mrb_value
otherBasis_2(int val, mrb_value __self__, mrb_value arg0, mrb_value arg1);
mrb_value
clamp_1(int val, mrb_value __self__, mrb_value arg0);
mrb_value
n_set_1(int val, mrb_value __self__, mrb_value arg0);
mrb_value
n_0(int val, mrb_value __self__);
mrb_value
pl_set_1(int val, mrb_value __self__, mrb_value arg0);
mrb_value
pl_0(int val, mrb_value __self__);
mrb_value
hit_set_1(int val, mrb_value __self__, mrb_value arg0);
mrb_value
hit_0(int val, mrb_value __self__);
mrb_value
t_set_1(int val, mrb_value __self__, mrb_value arg0);
mrb_value
t_0(int val, mrb_value __self__);
mrb_value
dir_set_1(int val, mrb_value __self__, mrb_value arg0);
mrb_value
dir_0(int val, mrb_value __self__);
mrb_value
org_set_1(int val, mrb_value __self__, mrb_value arg0);
mrb_value
org_0(int val, mrb_value __self__);
mrb_value
intersect_2(int val, mrb_value __self__, mrb_value arg0, mrb_value arg1);
mrb_value
radius_0(int val, mrb_value __self__);
mrb_value
center_0(int val, mrb_value __self__);
mrb_value
vnormalize_0(int val, mrb_value __self__);
mrb_value
vlength_0(int val, mrb_value __self__);
mrb_value
vdot_1(int val, mrb_value __self__, mrb_value arg0);
mrb_value
vcross_1(int val, mrb_value __self__, mrb_value arg0);
mrb_value
vsub_1(int val, mrb_value __self__, mrb_value arg0);
mrb_value
vadd_1(int val, mrb_value __self__, mrb_value arg0);
mrb_value
z_0(int val, mrb_value __self__);
mrb_value
y_0(int val, mrb_value __self__);
mrb_value
x_0(int val, mrb_value __self__);
mrb_value
z_set_1(int val, mrb_value __self__, mrb_value arg0);
mrb_value
y_set_1(int val, mrb_value __self__, mrb_value arg0);
mrb_value
x_set_1(int val, mrb_value __self__, mrb_value arg0);
mrb_value
rand_0(int val, mrb_value __self__);
mrb_value
new_0(int val, mrb_value __self__)
{
	struct RClass *c = mrb_class_ptr(__self__);
	struct RObject *o;
	enum mrb_vtype ttype = MRB_INSTANCE_TT(c);
	mrb_value obj;
	if (ttype == 0) ttype = MRB_TT_OBJECT;
	o = (struct RObject*)mrb_obj_alloc(mrb, ttype, c);
	obj = mrb_obj_value(o);
	if (c == mrb_class_get(mrb, "Scene")) {
		Scene_initialize(obj);
	} else 	if (c == mrb_class_get(mrb, "Isect")) {
		Isect_initialize(obj);
	} else {
		mrb_funcall(mrb, obj, "initialize", 0);
	}
return obj;
}

mrb_value
new_1(int val, mrb_value __self__, mrb_value arg0)
{
	struct RClass *c = mrb_class_ptr(__self__);
	struct RObject *o;
	enum mrb_vtype ttype = MRB_INSTANCE_TT(c);
	mrb_value obj;
	if (ttype == 0) ttype = MRB_TT_OBJECT;
	o = (struct RObject*)mrb_obj_alloc(mrb, ttype, c);
	obj = mrb_obj_value(o);
{
		mrb_funcall(mrb, obj, "initialize", 1, arg0);
	}
return obj;
}

mrb_value
new_2(int val, mrb_value __self__, mrb_value arg0, mrb_value arg1)
{
	struct RClass *c = mrb_class_ptr(__self__);
	struct RObject *o;
	enum mrb_vtype ttype = MRB_INSTANCE_TT(c);
	mrb_value obj;
	if (ttype == 0) ttype = MRB_TT_OBJECT;
	o = (struct RObject*)mrb_obj_alloc(mrb, ttype, c);
	obj = mrb_obj_value(o);
	if (c == mrb_class_get(mrb, "Ray")) {
		Ray_initialize(obj, arg0, arg1);
	} else 	if (c == mrb_class_get(mrb, "Plane")) {
		Plane_initialize(obj, arg0, arg1);
	} else 	if (c == mrb_class_get(mrb, "Sphere")) {
		Sphere_initialize(obj, arg0, arg1);
	} else {
		mrb_funcall(mrb, obj, "initialize", 2, arg0, arg1);
	}
return obj;
}

mrb_value
new_3(int val, mrb_value __self__, mrb_value arg0, mrb_value arg1, mrb_value arg2)
{
	struct RClass *c = mrb_class_ptr(__self__);
	struct RObject *o;
	enum mrb_vtype ttype = MRB_INSTANCE_TT(c);
	mrb_value obj;
	if (ttype == 0) ttype = MRB_TT_OBJECT;
	o = (struct RObject*)mrb_obj_alloc(mrb, ttype, c);
	obj = mrb_obj_value(o);
	if (c == mrb_class_get(mrb, "Vec")) {
		Vec_initialize(obj, arg0, arg1, arg2);
	} else {
		mrb_funcall(mrb, obj, "initialize", 3, arg0, arg1, arg2);
	}
return obj;
}

mrb_value IMAGE_WIDTH;
mrb_value IMAGE_HEIGHT;
mrb_value NSUBSAMPLES;
mrb_value NAO_SAMPLES;
mrb_value BNUM;
mrb_value BNUMF;
mrb_value Vec;
mrb_value Math;
mrb_value Sphere;
mrb_value Plane;
mrb_value Rand;
mrb_value Ray;
mrb_value Isect;
mrb_value Scene;
mrb_value
Rand_rand(mrb_value __self__)
{
	mrb_value x;
	mrb_value t;
	mrb_value w;

	x = mrb_cv_get(mrb, __self__, mrb_intern(mrb, "@x"));
	t = num_xor_1(1, x, (num_lshift_1(0, (num_and_1(0, x, mrb_fixnum_value(0xfffff))), mrb_fixnum_value(11))));
	w = mrb_cv_get(mrb, __self__, mrb_intern(mrb, "@w"));
	mrb_cv_set(mrb, __self__, mrb_intern(mrb, "@z"), w);
	mrb_cv_set(mrb, __self__, mrb_intern(mrb, "@y"), mrb_cv_get(mrb, __self__, mrb_intern(mrb, "@z")));
	mrb_cv_set(mrb, __self__, mrb_intern(mrb, "@x"), mrb_cv_get(mrb, __self__, mrb_intern(mrb, "@y")));
	mrb_cv_set(mrb, __self__, mrb_intern(mrb, "@w"), (num_xor_1(0, num_xor_1(1, w, (num_rshift_1(0, w, mrb_fixnum_value(19)))), (num_xor_1(0, t, (num_rshift_1(0, t, mrb_fixnum_value(8))))))));
	return num_div_1(1, (num_mod_1(0, mrb_cv_get(mrb, __self__, mrb_intern(mrb, "@w")), BNUM)), BNUMF);
}

mrb_value
Vec_vnormalize(mrb_value __self__)
{
	mrb_value len;
	mrb_value v;

	len = vlength_0(1, __self__);
	v = new_3(1, Vec, mrb_iv_get(mrb, __self__, mrb_intern(mrb, "x")), mrb_iv_get(mrb, __self__, mrb_intern(mrb, "y")), mrb_iv_get(mrb, __self__, mrb_intern(mrb, "z")));
	if ( mrb_bool(num_gt_1(1, len, mrb_float_value(1.0e-17))) )
	{
		x_set_1(0, v, num_div_1(1, x_0(1, v), len));
		y_set_1(0, v, num_div_1(1, y_0(1, v), len));
		z_set_1(0, v, num_div_1(1, z_0(1, v), len));
	}
	return v;
}

mrb_value
Vec_vlength(mrb_value __self__)
{
	return sqrt_1(1, Math, num_add_1(1, num_add_1(1, num_mul_1(1, mrb_iv_get(mrb, __self__, mrb_intern(mrb, "x")), mrb_iv_get(mrb, __self__, mrb_intern(mrb, "x"))), num_mul_1(1, mrb_iv_get(mrb, __self__, mrb_intern(mrb, "y")), mrb_iv_get(mrb, __self__, mrb_intern(mrb, "y")))), num_mul_1(1, mrb_iv_get(mrb, __self__, mrb_intern(mrb, "z")), mrb_iv_get(mrb, __self__, mrb_intern(mrb, "z")))));
}

mrb_value
Vec_vdot(mrb_value __self__, mrb_value b)
{
	mrb_value r;

	r = num_add_1(1, num_add_1(1, num_mul_1(1, mrb_iv_get(mrb, __self__, mrb_intern(mrb, "x")), x_0(1, b)), num_mul_1(1, mrb_iv_get(mrb, __self__, mrb_intern(mrb, "y")), y_0(1, b))), num_mul_1(1, mrb_iv_get(mrb, __self__, mrb_intern(mrb, "z")), z_0(1, b)));
	return r;
}

mrb_value
Vec_vcross(mrb_value __self__, mrb_value b)
{
	return new_3(1, Vec, num_sub_1(1, num_mul_1(1, mrb_iv_get(mrb, __self__, mrb_intern(mrb, "y")), z_0(1, b)), num_mul_1(1, mrb_iv_get(mrb, __self__, mrb_intern(mrb, "z")), y_0(1, b))), num_sub_1(1, num_mul_1(1, mrb_iv_get(mrb, __self__, mrb_intern(mrb, "z")), x_0(1, b)), num_mul_1(1, mrb_iv_get(mrb, __self__, mrb_intern(mrb, "x")), z_0(1, b))), num_sub_1(1, num_mul_1(1, mrb_iv_get(mrb, __self__, mrb_intern(mrb, "x")), y_0(1, b)), num_mul_1(1, mrb_iv_get(mrb, __self__, mrb_intern(mrb, "y")), x_0(1, b))));
}

mrb_value
Vec_vsub(mrb_value __self__, mrb_value b)
{
	return new_3(1, Vec, num_sub_1(1, mrb_iv_get(mrb, __self__, mrb_intern(mrb, "x")), x_0(1, b)), num_sub_1(1, mrb_iv_get(mrb, __self__, mrb_intern(mrb, "y")), y_0(1, b)), num_sub_1(1, mrb_iv_get(mrb, __self__, mrb_intern(mrb, "z")), z_0(1, b)));
}

mrb_value
Vec_vadd(mrb_value __self__, mrb_value b)
{
	return new_3(1, Vec, num_add_1(1, mrb_iv_get(mrb, __self__, mrb_intern(mrb, "x")), x_0(1, b)), num_add_1(1, mrb_iv_get(mrb, __self__, mrb_intern(mrb, "y")), y_0(1, b)), num_add_1(1, mrb_iv_get(mrb, __self__, mrb_intern(mrb, "z")), z_0(1, b)));
}

mrb_value
Vec_z(mrb_value __self__)
{
	return mrb_iv_get(mrb, __self__, mrb_intern(mrb, "z"));
}

mrb_value
Vec_y(mrb_value __self__)
{
	return mrb_iv_get(mrb, __self__, mrb_intern(mrb, "y"));
}

mrb_value
Vec_x(mrb_value __self__)
{
	return mrb_iv_get(mrb, __self__, mrb_intern(mrb, "x"));
}

mrb_value
Vec_z_set(mrb_value __self__, mrb_value v)
{
	mrb_iv_set(mrb, __self__, mrb_intern(mrb, "z"), v);
	return mrb_iv_get(mrb, __self__, mrb_intern(mrb, "z"));
}

mrb_value
Vec_y_set(mrb_value __self__, mrb_value v)
{
	mrb_iv_set(mrb, __self__, mrb_intern(mrb, "y"), v);
	return mrb_iv_get(mrb, __self__, mrb_intern(mrb, "y"));
}

mrb_value
Vec_x_set(mrb_value __self__, mrb_value v)
{
	mrb_iv_set(mrb, __self__, mrb_intern(mrb, "x"), v);
	return mrb_iv_get(mrb, __self__, mrb_intern(mrb, "x"));
}

mrb_value
Vec_initialize(mrb_value __self__, mrb_value x, mrb_value y, mrb_value z)
{
	mrb_iv_set(mrb, __self__, mrb_intern(mrb, "x"), x);
	mrb_iv_set(mrb, __self__, mrb_intern(mrb, "y"), y);
	mrb_iv_set(mrb, __self__, mrb_intern(mrb, "z"), z);
	return mrb_iv_get(mrb, __self__, mrb_intern(mrb, "z"));
}

mrb_value
Sphere_intersect(mrb_value __self__, mrb_value ray, mrb_value isect)
{
	mrb_value rs;
	mrb_value b;
	mrb_value c;
	mrb_value d;
	mrb_value t;
	mrb_value n;

	rs = vsub_1(1, org_0(1, ray), mrb_iv_get(mrb, __self__, mrb_intern(mrb, "center")));
	b = vdot_1(1, rs, dir_0(1, ray));
	c = num_sub_1(1, vdot_1(1, rs, rs), (num_mul_1(0, mrb_iv_get(mrb, __self__, mrb_intern(mrb, "radius")), mrb_iv_get(mrb, __self__, mrb_intern(mrb, "radius")))));
	d = num_sub_1(1, num_mul_1(1, b, b), c);
	if ( mrb_bool(num_gt_1(1, d, mrb_float_value(0.0))) )
	{
		t = num_sub_1(1, num_uminus_0(1, b), sqrt_1(1, Math, d));
		if ( mrb_bool(( mrb_bool(num_gt_1(1, t, mrb_float_value(0.0))) ? num_lt_1(1, t, t_0(1, isect)) : num_gt_1(1, t, mrb_float_value(0.0)) )) )
		{
			t_set_1(0, isect, t);
			hit_set_1(0, isect, mrb_true_value());
			pl_set_1(0, isect, new_3(1, Vec, num_add_1(1, x_0(1, org_0(1, ray)), num_mul_1(1, x_0(1, dir_0(1, ray)), t)), num_add_1(1, y_0(1, org_0(1, ray)), num_mul_1(1, y_0(1, dir_0(1, ray)), t)), num_add_1(1, z_0(1, org_0(1, ray)), num_mul_1(1, z_0(1, dir_0(1, ray)), t))));
			n = vsub_1(1, pl_0(1, isect), mrb_iv_get(mrb, __self__, mrb_intern(mrb, "center")));
			return n_set_1(1, isect, vnormalize_0(1, n));
		}
		else		return mrb_nil_value();
	}
	else	return mrb_nil_value();
}

mrb_value
Sphere_radius(mrb_value __self__)
{
	return mrb_iv_get(mrb, __self__, mrb_intern(mrb, "radius"));
}

mrb_value
Sphere_center(mrb_value __self__)
{
	return mrb_iv_get(mrb, __self__, mrb_intern(mrb, "center"));
}

mrb_value
Sphere_initialize(mrb_value __self__, mrb_value center, mrb_value radius)
{
	mrb_iv_set(mrb, __self__, mrb_intern(mrb, "center"), center);
	mrb_iv_set(mrb, __self__, mrb_intern(mrb, "radius"), radius);
	return mrb_iv_get(mrb, __self__, mrb_intern(mrb, "radius"));
}

mrb_value
Plane_intersect(mrb_value __self__, mrb_value ray, mrb_value isect)
{
	mrb_value d;
	mrb_value v;
	mrb_value v0;
	mrb_value t;

	d = num_uminus_0(1, vdot_1(1, mrb_iv_get(mrb, __self__, mrb_intern(mrb, "p")), mrb_iv_get(mrb, __self__, mrb_intern(mrb, "n"))));
	v = vdot_1(1, dir_0(1, ray), mrb_iv_get(mrb, __self__, mrb_intern(mrb, "n")));
	v0 = v;
	if ( mrb_bool(num_lt_1(1, v, mrb_float_value(0.0))) )
	{
		v0 = num_uminus_0(1, v);
	}
	if ( mrb_bool(num_lt_1(1, v0, mrb_float_value(1.0e-17))) )
	{
		return mrb_nil_value();
	}
	t = num_div_1(1, num_uminus_0(1, (num_add_1(0, vdot_1(1, org_0(1, ray), mrb_iv_get(mrb, __self__, mrb_intern(mrb, "n"))), d))), v);
	if ( mrb_bool(( mrb_bool(num_gt_1(1, t, mrb_float_value(0.0))) ? num_lt_1(1, t, t_0(1, isect)) : num_gt_1(1, t, mrb_float_value(0.0)) )) )
	{
		hit_set_1(0, isect, mrb_true_value());
		t_set_1(0, isect, t);
		n_set_1(0, isect, mrb_iv_get(mrb, __self__, mrb_intern(mrb, "n")));
		return pl_set_1(1, isect, new_3(1, Vec, num_add_1(1, x_0(1, org_0(1, ray)), num_mul_1(1, t, x_0(1, dir_0(1, ray)))), num_add_1(1, y_0(1, org_0(1, ray)), num_mul_1(1, t, y_0(1, dir_0(1, ray)))), num_add_1(1, z_0(1, org_0(1, ray)), num_mul_1(1, t, z_0(1, dir_0(1, ray))))));
	}
	else	return mrb_nil_value();
}

mrb_value
Plane_initialize(mrb_value __self__, mrb_value p, mrb_value n)
{
	mrb_iv_set(mrb, __self__, mrb_intern(mrb, "p"), p);
	mrb_iv_set(mrb, __self__, mrb_intern(mrb, "n"), n);
	return mrb_iv_get(mrb, __self__, mrb_intern(mrb, "n"));
}

mrb_value
Ray_dir_set(mrb_value __self__, mrb_value v)
{
	mrb_iv_set(mrb, __self__, mrb_intern(mrb, "dir"), v);
	return mrb_iv_get(mrb, __self__, mrb_intern(mrb, "dir"));
}

mrb_value
Ray_dir(mrb_value __self__)
{
	return mrb_iv_get(mrb, __self__, mrb_intern(mrb, "dir"));
}

mrb_value
Ray_org_set(mrb_value __self__, mrb_value v)
{
	mrb_iv_set(mrb, __self__, mrb_intern(mrb, "org"), v);
	return mrb_iv_get(mrb, __self__, mrb_intern(mrb, "org"));
}

mrb_value
Ray_org(mrb_value __self__)
{
	return mrb_iv_get(mrb, __self__, mrb_intern(mrb, "org"));
}

mrb_value
Ray_initialize(mrb_value __self__, mrb_value org, mrb_value dir)
{
	mrb_iv_set(mrb, __self__, mrb_intern(mrb, "org"), org);
	mrb_iv_set(mrb, __self__, mrb_intern(mrb, "dir"), dir);
	return mrb_iv_get(mrb, __self__, mrb_intern(mrb, "dir"));
}

mrb_value
Isect_n_set(mrb_value __self__, mrb_value v)
{
	mrb_iv_set(mrb, __self__, mrb_intern(mrb, "n"), v);
	return mrb_iv_get(mrb, __self__, mrb_intern(mrb, "n"));
}

mrb_value
Isect_n(mrb_value __self__)
{
	return mrb_iv_get(mrb, __self__, mrb_intern(mrb, "n"));
}

mrb_value
Isect_pl_set(mrb_value __self__, mrb_value v)
{
	mrb_iv_set(mrb, __self__, mrb_intern(mrb, "pl"), v);
	return mrb_iv_get(mrb, __self__, mrb_intern(mrb, "pl"));
}

mrb_value
Isect_pl(mrb_value __self__)
{
	return mrb_iv_get(mrb, __self__, mrb_intern(mrb, "pl"));
}

mrb_value
Isect_hit_set(mrb_value __self__, mrb_value v)
{
	mrb_iv_set(mrb, __self__, mrb_intern(mrb, "hit"), v);
	return mrb_iv_get(mrb, __self__, mrb_intern(mrb, "hit"));
}

mrb_value
Isect_hit(mrb_value __self__)
{
	return mrb_iv_get(mrb, __self__, mrb_intern(mrb, "hit"));
}

mrb_value
Isect_t_set(mrb_value __self__, mrb_value v)
{
	mrb_iv_set(mrb, __self__, mrb_intern(mrb, "t"), v);
	return mrb_iv_get(mrb, __self__, mrb_intern(mrb, "t"));
}

mrb_value
Isect_t(mrb_value __self__)
{
	return mrb_iv_get(mrb, __self__, mrb_intern(mrb, "t"));
}

mrb_value
Isect_initialize(mrb_value __self__)
{
	mrb_iv_set(mrb, __self__, mrb_intern(mrb, "t"), mrb_float_value(10000000.0));
	mrb_iv_set(mrb, __self__, mrb_intern(mrb, "hit"), mrb_false_value());
	mrb_iv_set(mrb, __self__, mrb_intern(mrb, "pl"), new_3(1, Vec, mrb_float_value(0.0), mrb_float_value(0.0), mrb_float_value(0.0)));
	mrb_iv_set(mrb, __self__, mrb_intern(mrb, "n"), new_3(1, Vec, mrb_float_value(0.0), mrb_float_value(0.0), mrb_float_value(0.0)));
	return mrb_iv_get(mrb, __self__, mrb_intern(mrb, "n"));
}

mrb_value
clamp(mrb_value __self__, mrb_value f)
{
	mrb_value i;

	i = num_mul_1(1, f, mrb_float_value(255.5));
	if ( mrb_bool(num_gt_1(1, i, mrb_float_value(255.0))) )
	{
		i = mrb_float_value(255.0);
	}
	if ( mrb_bool(num_lt_1(1, i, mrb_float_value(0.0))) )
	{
		i = mrb_float_value(0.0);
	}
	return to_i_0(1, i);
}

mrb_value
otherBasis(mrb_value __self__, mrb_value basis, mrb_value n)
{
	hpc_ary_aset_2(0, basis, mrb_fixnum_value(2), new_3(1, Vec, x_0(1, n), y_0(1, n), z_0(1, n)));
	hpc_ary_aset_2(0, basis, mrb_fixnum_value(1), new_3(1, Vec, mrb_float_value(0.0), mrb_float_value(0.0), mrb_float_value(0.0)));
	if ( mrb_bool(( mrb_bool(num_lt_1(1, x_0(1, n), mrb_float_value(0.6))) ? num_gt_1(1, x_0(1, n), mrb_float_value(-0.6)) : num_lt_1(1, x_0(1, n), mrb_float_value(0.6)) )) )
	{
		x_set_1(0, hpc_ary_aget_1(1, basis, mrb_fixnum_value(1)), mrb_float_value(1.0));
	}
	else	if ( mrb_bool(( mrb_bool(num_lt_1(1, y_0(1, n), mrb_float_value(0.6))) ? num_gt_1(1, y_0(1, n), mrb_float_value(-0.6)) : num_lt_1(1, y_0(1, n), mrb_float_value(0.6)) )) )
	{
		y_set_1(0, hpc_ary_aget_1(1, basis, mrb_fixnum_value(1)), mrb_float_value(1.0));
	}
	else	if ( mrb_bool(( mrb_bool(num_lt_1(1, z_0(1, n), mrb_float_value(0.6))) ? num_gt_1(1, z_0(1, n), mrb_float_value(-0.6)) : num_lt_1(1, z_0(1, n), mrb_float_value(0.6)) )) )
	{
		z_set_1(0, hpc_ary_aget_1(1, basis, mrb_fixnum_value(1)), mrb_float_value(1.0));
	}
	else	{
		x_set_1(0, hpc_ary_aget_1(1, basis, mrb_fixnum_value(1)), mrb_float_value(1.0));
	}
	hpc_ary_aset_2(0, basis, mrb_fixnum_value(0), vcross_1(1, hpc_ary_aget_1(1, basis, mrb_fixnum_value(1)), hpc_ary_aget_1(1, basis, mrb_fixnum_value(2))));
	hpc_ary_aset_2(0, basis, mrb_fixnum_value(0), vnormalize_0(1, hpc_ary_aget_1(1, basis, mrb_fixnum_value(0))));
	hpc_ary_aset_2(0, basis, mrb_fixnum_value(1), vcross_1(1, hpc_ary_aget_1(1, basis, mrb_fixnum_value(2)), hpc_ary_aget_1(1, basis, mrb_fixnum_value(0))));
	return hpc_ary_aset_2(1, basis, mrb_fixnum_value(1), vnormalize_0(1, hpc_ary_aget_1(1, basis, mrb_fixnum_value(1))));
}

mrb_value
Scene_render(mrb_value __self__, mrb_value w, mrb_value h, mrb_value nsubsamples)
{
	mrb_value cnt;
	mrb_value nsf;

	cnt = mrb_fixnum_value(0);
	nsf = to_f_0(1, nsubsamples);
	mrb_int __y = mrb_fixnum(mrb_fixnum_value(0));
	mrb_int __y_last = mrb_fixnum(h);
	for (; __y < __y_last; ++__y) {
		int ai = mrb_gc_arena_save(mrb);
		mrb_value y = mrb_fixnum_value(__y);
		mrb_int __x = mrb_fixnum(mrb_fixnum_value(0));
		mrb_int __x_last = mrb_fixnum(w);
		for (; __x < __x_last; ++__x) {
			int ai = mrb_gc_arena_save(mrb);
			mrb_value x = mrb_fixnum_value(__x);
			mrb_value rad;
			mrb_value r;
			mrb_value g;
			mrb_value b;

			rad = new_3(1, Vec, mrb_float_value(0.0), mrb_float_value(0.0), mrb_float_value(0.0));
			mrb_int __v = mrb_fixnum(mrb_fixnum_value(0));
			mrb_int __v_last = mrb_fixnum(nsubsamples);
			for (; __v < __v_last; ++__v) {
				int ai = mrb_gc_arena_save(mrb);
				mrb_value v = mrb_fixnum_value(__v);
				mrb_int __u = mrb_fixnum(mrb_fixnum_value(0));
				mrb_int __u_last = mrb_fixnum(nsubsamples);
				for (; __u < __u_last; ++__u) {
					int ai = mrb_gc_arena_save(mrb);
					mrb_value u = mrb_fixnum_value(__u);
					mrb_value wf;
					mrb_value hf;
					mrb_value xf;
					mrb_value yf;
					mrb_value uf;
					mrb_value vf;
					mrb_value px;
					mrb_value py;
					mrb_value eye;
					mrb_value ray;
					mrb_value isect;
					mrb_value col;

					cnt = num_add_1(1, cnt, mrb_fixnum_value(1));
					wf = to_f_0(1, w);
					hf = to_f_0(1, h);
					xf = to_f_0(1, x);
					yf = to_f_0(1, y);
					uf = to_f_0(1, u);
					vf = to_f_0(1, v);
					px = num_div_1(1, (num_sub_1(0, num_add_1(1, xf, (num_div_1(0, uf, nsf))), (num_div_1(0, wf, mrb_float_value(2.0))))), (num_div_1(0, wf, mrb_float_value(2.0))));
					py = num_div_1(1, num_uminus_0(1, (num_sub_1(0, num_add_1(1, yf, (num_div_1(0, vf, nsf))), (num_div_1(0, hf, mrb_float_value(2.0)))))), (num_div_1(0, hf, mrb_float_value(2.0))));
					eye = vnormalize_0(1, new_3(1, Vec, px, py, mrb_float_value(-1.0)));
					ray = new_2(1, Ray, new_3(1, Vec, mrb_float_value(0.0), mrb_float_value(0.0), mrb_float_value(0.0)), eye);
					isect = new_0(1, Isect);
					intersect_2(0, hpc_ary_aget_1(1, mrb_iv_get(mrb, __self__, mrb_intern(mrb, "spheres")), mrb_fixnum_value(0)), ray, isect);
					intersect_2(0, hpc_ary_aget_1(1, mrb_iv_get(mrb, __self__, mrb_intern(mrb, "spheres")), mrb_fixnum_value(1)), ray, isect);
					intersect_2(0, hpc_ary_aget_1(1, mrb_iv_get(mrb, __self__, mrb_intern(mrb, "spheres")), mrb_fixnum_value(2)), ray, isect);
					intersect_2(0, mrb_iv_get(mrb, __self__, mrb_intern(mrb, "plane")), ray, isect);
					if ( mrb_bool(hit_0(1, isect)) )
					{
						col = ambient_occlusion_1(1, __self__, isect);
						x_set_1(0, rad, num_add_1(1, x_0(1, rad), x_0(1, col)));
						y_set_1(0, rad, num_add_1(1, y_0(1, rad), y_0(1, col)));
						z_set_1(0, rad, num_add_1(1, z_0(1, rad), z_0(1, col)));
					}
					mrb_gc_arena_restore(mrb, ai);
				}
				mrb_gc_arena_restore(mrb, ai);
			}
			r = num_div_1(1, x_0(1, rad), (num_mul_1(0, nsf, nsf)));
			g = num_div_1(1, y_0(1, rad), (num_mul_1(0, nsf, nsf)));
			b = num_div_1(1, z_0(1, rad), (num_mul_1(0, nsf, nsf)));
			print_1(0, __self__, chr_0(1, clamp_1(1, __self__, r)));
			print_1(0, __self__, chr_0(1, clamp_1(1, __self__, g)));
			print_1(0, __self__, chr_0(1, clamp_1(1, __self__, b)));
			mrb_gc_arena_restore(mrb, ai);
		}
		mrb_gc_arena_restore(mrb, ai);
	}
	return mrb_nil_value();
}

mrb_value
Scene_ambient_occlusion(mrb_value __self__, mrb_value isect)
{
	mrb_value basis;
	mrb_value ntheta;
	mrb_value nphi;
	mrb_value eps;
	mrb_value occlusion;
	mrb_value p0;

	basis = new_1(1, mrb_obj_value(mrb->array_class), mrb_fixnum_value(3));
	otherBasis_2(0, __self__, basis, n_0(1, isect));
	ntheta = NAO_SAMPLES;
	nphi = NAO_SAMPLES;
	eps = mrb_float_value(0.0001);
	occlusion = mrb_float_value(0.0);
	p0 = new_3(1, Vec, num_add_1(1, x_0(1, pl_0(1, isect)), num_mul_1(1, eps, x_0(1, n_0(1, isect)))), num_add_1(1, y_0(1, pl_0(1, isect)), num_mul_1(1, eps, y_0(1, n_0(1, isect)))), num_add_1(1, z_0(1, pl_0(1, isect)), num_mul_1(1, eps, z_0(1, n_0(1, isect)))));
	mrb_int __j = mrb_fixnum(mrb_fixnum_value(0));
	mrb_int __j_last = mrb_fixnum(nphi);
	for (; __j < __j_last; ++__j) {
		int ai = mrb_gc_arena_save(mrb);
		mrb_value j = mrb_fixnum_value(__j);
		mrb_int __i = mrb_fixnum(mrb_fixnum_value(0));
		mrb_int __i_last = mrb_fixnum(ntheta);
		for (; __i < __i_last; ++__i) {
			int ai = mrb_gc_arena_save(mrb);
			mrb_value i = mrb_fixnum_value(__i);
			mrb_value r;
			mrb_value phi;
			mrb_value x;
			mrb_value y;
			mrb_value z;
			mrb_value rx;
			mrb_value ry;
			mrb_value rz;
			mrb_value raydir;
			mrb_value ray;
			mrb_value occisect;

			r = rand_0(1, Rand);
			phi = num_mul_1(1, num_mul_1(1, mrb_float_value(2.0), mrb_float_value(3.14159265)), rand_0(1, Rand));
			x = num_mul_1(1, cos_1(1, Math, phi), sqrt_1(1, Math, num_sub_1(1, mrb_float_value(1.0), r)));
			y = num_mul_1(1, sin_1(1, Math, phi), sqrt_1(1, Math, num_sub_1(1, mrb_float_value(1.0), r)));
			z = sqrt_1(1, Math, r);
			rx = num_add_1(1, num_add_1(1, num_mul_1(1, x, x_0(1, hpc_ary_aget_1(1, basis, mrb_fixnum_value(0)))), num_mul_1(1, y, x_0(1, hpc_ary_aget_1(1, basis, mrb_fixnum_value(1))))), num_mul_1(1, z, x_0(1, hpc_ary_aget_1(1, basis, mrb_fixnum_value(2)))));
			ry = num_add_1(1, num_add_1(1, num_mul_1(1, x, y_0(1, hpc_ary_aget_1(1, basis, mrb_fixnum_value(0)))), num_mul_1(1, y, y_0(1, hpc_ary_aget_1(1, basis, mrb_fixnum_value(1))))), num_mul_1(1, z, y_0(1, hpc_ary_aget_1(1, basis, mrb_fixnum_value(2)))));
			rz = num_add_1(1, num_add_1(1, num_mul_1(1, x, z_0(1, hpc_ary_aget_1(1, basis, mrb_fixnum_value(0)))), num_mul_1(1, y, z_0(1, hpc_ary_aget_1(1, basis, mrb_fixnum_value(1))))), num_mul_1(1, z, z_0(1, hpc_ary_aget_1(1, basis, mrb_fixnum_value(2)))));
			raydir = new_3(1, Vec, rx, ry, rz);
			ray = new_2(1, Ray, p0, raydir);
			occisect = new_0(1, Isect);
			intersect_2(0, hpc_ary_aget_1(1, mrb_iv_get(mrb, __self__, mrb_intern(mrb, "spheres")), mrb_fixnum_value(0)), ray, occisect);
			intersect_2(0, hpc_ary_aget_1(1, mrb_iv_get(mrb, __self__, mrb_intern(mrb, "spheres")), mrb_fixnum_value(1)), ray, occisect);
			intersect_2(0, hpc_ary_aget_1(1, mrb_iv_get(mrb, __self__, mrb_intern(mrb, "spheres")), mrb_fixnum_value(2)), ray, occisect);
			intersect_2(0, mrb_iv_get(mrb, __self__, mrb_intern(mrb, "plane")), ray, occisect);
			if ( mrb_bool(hit_0(1, occisect)) )
			{
				occlusion = num_add_1(1, occlusion, mrb_float_value(1.0));
			}
			mrb_gc_arena_restore(mrb, ai);
		}
		mrb_gc_arena_restore(mrb, ai);
	}
	occlusion = num_div_1(1, (num_sub_1(0, num_mul_1(1, to_f_0(1, ntheta), to_f_0(1, nphi)), occlusion)), (num_mul_1(0, to_f_0(1, ntheta), to_f_0(1, nphi))));
	return new_3(1, Vec, occlusion, occlusion, occlusion);
}

mrb_value
Scene_initialize(mrb_value __self__)
{
	mrb_iv_set(mrb, __self__, mrb_intern(mrb, "spheres"), new_0(1, mrb_obj_value(mrb->array_class)));
	hpc_ary_aset_2(0, mrb_iv_get(mrb, __self__, mrb_intern(mrb, "spheres")), mrb_fixnum_value(0), new_2(1, Sphere, new_3(1, Vec, mrb_float_value(-2.0), mrb_float_value(0.0), mrb_float_value(-3.5)), mrb_float_value(0.5)));
	hpc_ary_aset_2(0, mrb_iv_get(mrb, __self__, mrb_intern(mrb, "spheres")), mrb_fixnum_value(1), new_2(1, Sphere, new_3(1, Vec, mrb_float_value(-0.5), mrb_float_value(0.0), mrb_float_value(-3.0)), mrb_float_value(0.5)));
	hpc_ary_aset_2(0, mrb_iv_get(mrb, __self__, mrb_intern(mrb, "spheres")), mrb_fixnum_value(2), new_2(1, Sphere, new_3(1, Vec, mrb_float_value(1.0), mrb_float_value(0.0), mrb_float_value(-2.2)), mrb_float_value(0.5)));
	mrb_iv_set(mrb, __self__, mrb_intern(mrb, "plane"), new_2(1, Plane, new_3(1, Vec, mrb_float_value(0.0), mrb_float_value(-0.5), mrb_float_value(0.0)), new_3(1, Vec, mrb_float_value(0.0), mrb_float_value(1.0), mrb_float_value(0.0))));
	return mrb_iv_get(mrb, __self__, mrb_intern(mrb, "plane"));
}

void
compiled_main(mrb_value __self__, mrb_state * mrb)
{
	IMAGE_WIDTH = mrb_fixnum_value(256);
	IMAGE_HEIGHT = mrb_fixnum_value(256);
	NSUBSAMPLES = mrb_fixnum_value(2);
	NAO_SAMPLES = mrb_fixnum_value(8);
	Rand = mrb_obj_value(mrb_define_class(mrb, "Rand", mrb->object_class));
	Vec = mrb_obj_value(mrb_define_class(mrb, "Vec", mrb->object_class));
	Sphere = mrb_obj_value(mrb_define_class(mrb, "Sphere", mrb->object_class));
	Plane = mrb_obj_value(mrb_define_class(mrb, "Plane", mrb->object_class));
	Ray = mrb_obj_value(mrb_define_class(mrb, "Ray", mrb->object_class));
	Isect = mrb_obj_value(mrb_define_class(mrb, "Isect", mrb->object_class));
	Scene = mrb_obj_value(mrb_define_class(mrb, "Scene", mrb->object_class));
	print_1(0, __self__, mrb_str_new(mrb, "P6\n", 3));
	print_1(0, __self__, num_add_1(1, num_add_1(1, num_add_1(1, to_s_0(1, IMAGE_WIDTH), mrb_str_new(mrb, " ", 1)), to_s_0(1, IMAGE_HEIGHT)), mrb_str_new(mrb, "\n", 1)));
	print_1(0, __self__, mrb_str_new(mrb, "255\n", 4));
	render_3(0, new_0(1, Scene), IMAGE_WIDTH, IMAGE_HEIGHT, NSUBSAMPLES);
}

mrb_value
render_3(int val, mrb_value __self__, mrb_value arg0, mrb_value arg1, mrb_value arg2)
{
	int ai;
	if (!val) ai = mrb_gc_arena_save(mrb);
	mrb_value result;
	struct RClass *c = mrb_obj_class(mrb, __self__);
	if (c == mrb_class_get(mrb, "Scene")) {
		result = Scene_render(__self__, arg0, arg1, arg2);
	} else {
		result = mrb_funcall(mrb, __self__, "render", 3, arg0, arg1, arg2);
	}
	if (!val) mrb_gc_arena_restore(mrb,  ai);
	return result;
}

mrb_value
ambient_occlusion_1(int val, mrb_value __self__, mrb_value arg0)
{
	int ai;
	if (!val) ai = mrb_gc_arena_save(mrb);
	mrb_value result;
	struct RClass *c = mrb_obj_class(mrb, __self__);
	if (c == mrb_class_get(mrb, "Scene")) {
		result = Scene_ambient_occlusion(__self__, arg0);
	} else {
		result = mrb_funcall(mrb, __self__, "ambient_occlusion", 1, arg0);
	}
	if (!val) mrb_gc_arena_restore(mrb,  ai);
	return result;
}

mrb_value
otherBasis_2(int val, mrb_value __self__, mrb_value arg0, mrb_value arg1)
{
	return otherBasis(__self__, arg0, arg1);
}mrb_value
clamp_1(int val, mrb_value __self__, mrb_value arg0)
{
	return clamp(__self__, arg0);
}mrb_value
n_set_1(int val, mrb_value __self__, mrb_value arg0)
{
	int ai;
	if (!val) ai = mrb_gc_arena_save(mrb);
	mrb_value result;
	struct RClass *c = mrb_obj_class(mrb, __self__);
	if (c == mrb_class_get(mrb, "Isect")) {
		result = Isect_n_set(__self__, arg0);
	} else {
		result = mrb_funcall(mrb, __self__, "n=", 1, arg0);
	}
	if (!val) mrb_gc_arena_restore(mrb,  ai);
	return result;
}

mrb_value
n_0(int val, mrb_value __self__)
{
	int ai;
	if (!val) ai = mrb_gc_arena_save(mrb);
	mrb_value result;
	struct RClass *c = mrb_obj_class(mrb, __self__);
	if (c == mrb_class_get(mrb, "Isect")) {
		result = Isect_n(__self__);
	} else {
		result = mrb_funcall(mrb, __self__, "n", 0);
	}
	if (!val) mrb_gc_arena_restore(mrb,  ai);
	return result;
}

mrb_value
pl_set_1(int val, mrb_value __self__, mrb_value arg0)
{
	int ai;
	if (!val) ai = mrb_gc_arena_save(mrb);
	mrb_value result;
	struct RClass *c = mrb_obj_class(mrb, __self__);
	if (c == mrb_class_get(mrb, "Isect")) {
		result = Isect_pl_set(__self__, arg0);
	} else {
		result = mrb_funcall(mrb, __self__, "pl=", 1, arg0);
	}
	if (!val) mrb_gc_arena_restore(mrb,  ai);
	return result;
}

mrb_value
pl_0(int val, mrb_value __self__)
{
	int ai;
	if (!val) ai = mrb_gc_arena_save(mrb);
	mrb_value result;
	struct RClass *c = mrb_obj_class(mrb, __self__);
	if (c == mrb_class_get(mrb, "Isect")) {
		result = Isect_pl(__self__);
	} else {
		result = mrb_funcall(mrb, __self__, "pl", 0);
	}
	if (!val) mrb_gc_arena_restore(mrb,  ai);
	return result;
}

mrb_value
hit_set_1(int val, mrb_value __self__, mrb_value arg0)
{
	int ai;
	if (!val) ai = mrb_gc_arena_save(mrb);
	mrb_value result;
	struct RClass *c = mrb_obj_class(mrb, __self__);
	if (c == mrb_class_get(mrb, "Isect")) {
		result = Isect_hit_set(__self__, arg0);
	} else {
		result = mrb_funcall(mrb, __self__, "hit=", 1, arg0);
	}
	if (!val) mrb_gc_arena_restore(mrb,  ai);
	return result;
}

mrb_value
hit_0(int val, mrb_value __self__)
{
	int ai;
	if (!val) ai = mrb_gc_arena_save(mrb);
	mrb_value result;
	struct RClass *c = mrb_obj_class(mrb, __self__);
	if (c == mrb_class_get(mrb, "Isect")) {
		result = Isect_hit(__self__);
	} else {
		result = mrb_funcall(mrb, __self__, "hit", 0);
	}
	if (!val) mrb_gc_arena_restore(mrb,  ai);
	return result;
}

mrb_value
t_set_1(int val, mrb_value __self__, mrb_value arg0)
{
	int ai;
	if (!val) ai = mrb_gc_arena_save(mrb);
	mrb_value result;
	struct RClass *c = mrb_obj_class(mrb, __self__);
	if (c == mrb_class_get(mrb, "Isect")) {
		result = Isect_t_set(__self__, arg0);
	} else {
		result = mrb_funcall(mrb, __self__, "t=", 1, arg0);
	}
	if (!val) mrb_gc_arena_restore(mrb,  ai);
	return result;
}

mrb_value
t_0(int val, mrb_value __self__)
{
	int ai;
	if (!val) ai = mrb_gc_arena_save(mrb);
	mrb_value result;
	struct RClass *c = mrb_obj_class(mrb, __self__);
	if (c == mrb_class_get(mrb, "Isect")) {
		result = Isect_t(__self__);
	} else {
		result = mrb_funcall(mrb, __self__, "t", 0);
	}
	if (!val) mrb_gc_arena_restore(mrb,  ai);
	return result;
}

mrb_value
dir_set_1(int val, mrb_value __self__, mrb_value arg0)
{
	int ai;
	if (!val) ai = mrb_gc_arena_save(mrb);
	mrb_value result;
	struct RClass *c = mrb_obj_class(mrb, __self__);
	if (c == mrb_class_get(mrb, "Ray")) {
		result = Ray_dir_set(__self__, arg0);
	} else {
		result = mrb_funcall(mrb, __self__, "dir=", 1, arg0);
	}
	if (!val) mrb_gc_arena_restore(mrb,  ai);
	return result;
}

mrb_value
dir_0(int val, mrb_value __self__)
{
	int ai;
	if (!val) ai = mrb_gc_arena_save(mrb);
	mrb_value result;
	struct RClass *c = mrb_obj_class(mrb, __self__);
	if (c == mrb_class_get(mrb, "Ray")) {
		result = Ray_dir(__self__);
	} else {
		result = mrb_funcall(mrb, __self__, "dir", 0);
	}
	if (!val) mrb_gc_arena_restore(mrb,  ai);
	return result;
}

mrb_value
org_set_1(int val, mrb_value __self__, mrb_value arg0)
{
	int ai;
	if (!val) ai = mrb_gc_arena_save(mrb);
	mrb_value result;
	struct RClass *c = mrb_obj_class(mrb, __self__);
	if (c == mrb_class_get(mrb, "Ray")) {
		result = Ray_org_set(__self__, arg0);
	} else {
		result = mrb_funcall(mrb, __self__, "org=", 1, arg0);
	}
	if (!val) mrb_gc_arena_restore(mrb,  ai);
	return result;
}

mrb_value
org_0(int val, mrb_value __self__)
{
	int ai;
	if (!val) ai = mrb_gc_arena_save(mrb);
	mrb_value result;
	struct RClass *c = mrb_obj_class(mrb, __self__);
	if (c == mrb_class_get(mrb, "Ray")) {
		result = Ray_org(__self__);
	} else {
		result = mrb_funcall(mrb, __self__, "org", 0);
	}
	if (!val) mrb_gc_arena_restore(mrb,  ai);
	return result;
}

mrb_value
intersect_2(int val, mrb_value __self__, mrb_value arg0, mrb_value arg1)
{
	int ai;
	if (!val) ai = mrb_gc_arena_save(mrb);
	mrb_value result;
	struct RClass *c = mrb_obj_class(mrb, __self__);
	if (c == mrb_class_get(mrb, "Plane")) {
		result = Plane_intersect(__self__, arg0, arg1);
	} else 	if (c == mrb_class_get(mrb, "Sphere")) {
		result = Sphere_intersect(__self__, arg0, arg1);
	} else {
		result = mrb_funcall(mrb, __self__, "intersect", 2, arg0, arg1);
	}
	if (!val) mrb_gc_arena_restore(mrb,  ai);
	return result;
}

mrb_value
radius_0(int val, mrb_value __self__)
{
	int ai;
	if (!val) ai = mrb_gc_arena_save(mrb);
	mrb_value result;
	struct RClass *c = mrb_obj_class(mrb, __self__);
	if (c == mrb_class_get(mrb, "Sphere")) {
		result = Sphere_radius(__self__);
	} else {
		result = mrb_funcall(mrb, __self__, "radius", 0);
	}
	if (!val) mrb_gc_arena_restore(mrb,  ai);
	return result;
}

mrb_value
center_0(int val, mrb_value __self__)
{
	int ai;
	if (!val) ai = mrb_gc_arena_save(mrb);
	mrb_value result;
	struct RClass *c = mrb_obj_class(mrb, __self__);
	if (c == mrb_class_get(mrb, "Sphere")) {
		result = Sphere_center(__self__);
	} else {
		result = mrb_funcall(mrb, __self__, "center", 0);
	}
	if (!val) mrb_gc_arena_restore(mrb,  ai);
	return result;
}

mrb_value
vnormalize_0(int val, mrb_value __self__)
{
	int ai;
	if (!val) ai = mrb_gc_arena_save(mrb);
	mrb_value result;
	struct RClass *c = mrb_obj_class(mrb, __self__);
	if (c == mrb_class_get(mrb, "Vec")) {
		result = Vec_vnormalize(__self__);
	} else {
		result = mrb_funcall(mrb, __self__, "vnormalize", 0);
	}
	if (!val) mrb_gc_arena_restore(mrb,  ai);
	return result;
}

mrb_value
vlength_0(int val, mrb_value __self__)
{
	int ai;
	if (!val) ai = mrb_gc_arena_save(mrb);
	mrb_value result;
	struct RClass *c = mrb_obj_class(mrb, __self__);
	if (c == mrb_class_get(mrb, "Vec")) {
		result = Vec_vlength(__self__);
	} else {
		result = mrb_funcall(mrb, __self__, "vlength", 0);
	}
	if (!val) mrb_gc_arena_restore(mrb,  ai);
	return result;
}

mrb_value
vdot_1(int val, mrb_value __self__, mrb_value arg0)
{
	int ai;
	if (!val) ai = mrb_gc_arena_save(mrb);
	mrb_value result;
	struct RClass *c = mrb_obj_class(mrb, __self__);
	if (c == mrb_class_get(mrb, "Vec")) {
		result = Vec_vdot(__self__, arg0);
	} else {
		result = mrb_funcall(mrb, __self__, "vdot", 1, arg0);
	}
	if (!val) mrb_gc_arena_restore(mrb,  ai);
	return result;
}

mrb_value
vcross_1(int val, mrb_value __self__, mrb_value arg0)
{
	int ai;
	if (!val) ai = mrb_gc_arena_save(mrb);
	mrb_value result;
	struct RClass *c = mrb_obj_class(mrb, __self__);
	if (c == mrb_class_get(mrb, "Vec")) {
		result = Vec_vcross(__self__, arg0);
	} else {
		result = mrb_funcall(mrb, __self__, "vcross", 1, arg0);
	}
	if (!val) mrb_gc_arena_restore(mrb,  ai);
	return result;
}

mrb_value
vsub_1(int val, mrb_value __self__, mrb_value arg0)
{
	int ai;
	if (!val) ai = mrb_gc_arena_save(mrb);
	mrb_value result;
	struct RClass *c = mrb_obj_class(mrb, __self__);
	if (c == mrb_class_get(mrb, "Vec")) {
		result = Vec_vsub(__self__, arg0);
	} else {
		result = mrb_funcall(mrb, __self__, "vsub", 1, arg0);
	}
	if (!val) mrb_gc_arena_restore(mrb,  ai);
	return result;
}

mrb_value
vadd_1(int val, mrb_value __self__, mrb_value arg0)
{
	int ai;
	if (!val) ai = mrb_gc_arena_save(mrb);
	mrb_value result;
	struct RClass *c = mrb_obj_class(mrb, __self__);
	if (c == mrb_class_get(mrb, "Vec")) {
		result = Vec_vadd(__self__, arg0);
	} else {
		result = mrb_funcall(mrb, __self__, "vadd", 1, arg0);
	}
	if (!val) mrb_gc_arena_restore(mrb,  ai);
	return result;
}

mrb_value
z_0(int val, mrb_value __self__)
{
	int ai;
	if (!val) ai = mrb_gc_arena_save(mrb);
	mrb_value result;
	struct RClass *c = mrb_obj_class(mrb, __self__);
	if (c == mrb_class_get(mrb, "Vec")) {
		result = Vec_z(__self__);
	} else {
		result = mrb_funcall(mrb, __self__, "z", 0);
	}
	if (!val) mrb_gc_arena_restore(mrb,  ai);
	return result;
}

mrb_value
y_0(int val, mrb_value __self__)
{
	int ai;
	if (!val) ai = mrb_gc_arena_save(mrb);
	mrb_value result;
	struct RClass *c = mrb_obj_class(mrb, __self__);
	if (c == mrb_class_get(mrb, "Vec")) {
		result = Vec_y(__self__);
	} else {
		result = mrb_funcall(mrb, __self__, "y", 0);
	}
	if (!val) mrb_gc_arena_restore(mrb,  ai);
	return result;
}

mrb_value
x_0(int val, mrb_value __self__)
{
	int ai;
	if (!val) ai = mrb_gc_arena_save(mrb);
	mrb_value result;
	struct RClass *c = mrb_obj_class(mrb, __self__);
	if (c == mrb_class_get(mrb, "Vec")) {
		result = Vec_x(__self__);
	} else {
		result = mrb_funcall(mrb, __self__, "x", 0);
	}
	if (!val) mrb_gc_arena_restore(mrb,  ai);
	return result;
}

mrb_value
z_set_1(int val, mrb_value __self__, mrb_value arg0)
{
	int ai;
	if (!val) ai = mrb_gc_arena_save(mrb);
	mrb_value result;
	struct RClass *c = mrb_obj_class(mrb, __self__);
	if (c == mrb_class_get(mrb, "Vec")) {
		result = Vec_z_set(__self__, arg0);
	} else {
		result = mrb_funcall(mrb, __self__, "z=", 1, arg0);
	}
	if (!val) mrb_gc_arena_restore(mrb,  ai);
	return result;
}

mrb_value
y_set_1(int val, mrb_value __self__, mrb_value arg0)
{
	int ai;
	if (!val) ai = mrb_gc_arena_save(mrb);
	mrb_value result;
	struct RClass *c = mrb_obj_class(mrb, __self__);
	if (c == mrb_class_get(mrb, "Vec")) {
		result = Vec_y_set(__self__, arg0);
	} else {
		result = mrb_funcall(mrb, __self__, "y=", 1, arg0);
	}
	if (!val) mrb_gc_arena_restore(mrb,  ai);
	return result;
}

mrb_value
x_set_1(int val, mrb_value __self__, mrb_value arg0)
{
	int ai;
	if (!val) ai = mrb_gc_arena_save(mrb);
	mrb_value result;
	struct RClass *c = mrb_obj_class(mrb, __self__);
	if (c == mrb_class_get(mrb, "Vec")) {
		result = Vec_x_set(__self__, arg0);
	} else {
		result = mrb_funcall(mrb, __self__, "x=", 1, arg0);
	}
	if (!val) mrb_gc_arena_restore(mrb,  ai);
	return result;
}

mrb_value
rand_0(int val, mrb_value __self__)
{
	int ai;
	if (!val) ai = mrb_gc_arena_save(mrb);
	mrb_value result;
	struct RClass *c = mrb_obj_class(mrb, __self__);
	if (c == mrb_class_get(mrb, "Rand")) {
		result = Rand_rand(__self__);
	} else {
		result = mrb_funcall(mrb, __self__, "rand", 0);
	}
	if (!val) mrb_gc_arena_restore(mrb,  ai);
	return result;
}

